<html>
<head>
   <link rel="stylesheet" href="man.css">
   <title>What's new</title>
</head>
<body>
<div class="main">
<h1>What's New</h1>

<h2>JScheme 7.3: 6/26/2007</h2> 
<ul>
  <li>
    jsint.Import.forName: updated for minor bug with 1.6 jdk support
    when locating classes for array types.
  </li>
  <li>
    jsint.U.tail: added tail method
  </li>
</ul>

<h2>JScheme 7.2: 3/1/2005</h2> 
<ul><li>
Ken Anderson, one of the two main developers of JScheme died unexpectedly of a heart attack at the SPAM 2005 conference.
Ken was a gifted developer and a great guy who will be sorely missed.
</li><li>
JScheme now supports JDK1.5 (there were some problems with the new implementation of StringBuffer in j2sdk1.5)
</li></ul>

<h2>Expanded JScheme download: 8/2/04</h2> 
<ul>
<li> The JScheme download now comes bundled with the Jetty server jar files (from jetty.mortbay.org).
This makes it possible to start a Jetty webserver from inside a Scheme program.
We also have a Scheme webapp that can be dropped into a servlet container (or added
programmatically to a running Jetty server). The Scheme webapp
allows servlets and applets to be written in Scheme. 
</li>
<li> We have included several examples of interesting servlets and applets, 
including a classbrowser applet, a wiki server, and several simple demos.
</li>
</ul>



<h2>jscheme/contrib: 7/27/2004</h2>
<ul>
<li>
We've added a jscheme/contrib section which gives several examples of jscheme code.
In particular, it contains the code for 
<ol>
<li> a <a href="../contrib/jswebapp/jswebapp.html">
jscheme servlet webapp</a> that can be dropped
into any servlet container.</li>
<li> several <a href="../contrib/ia/ia.html">Interval Arithmetic evaluators and applets</a>, that show how
to integrate your own Java classes with JScheme applications and applets.
</li>
</ol>
The main webpage has also been redesigned and is now generated by evaluating the src/build/make-webpages script.
</li>
</ul>

<a href="literals.html#strongquasistring">Strong quasi-string notation</a> - we now have a slightly heavier notation

<h2>JScheme 7.1: 6/16/04</h2> 
<ul>
<li> <a href="literals.html#strongquasistring">Strong quasi-string notation</a> - we now have a slightly heavier notation
for quasi-strings (which uses #\{.... }\# #\[...]\# instead of {...}, [...] ). 
The advantage is that you can include text containing double quotes,
curly braces, and square brackets, without having to use escapes..</li>
</ul>

<h2>JScheme 7.0: 5/19/04</h2> 
<ul>
<li> <a href="api/jscheme/JScheme.html">Multiple Independent JScheme instances</a> -- 
we now have a modification JScheme.java of
JS.java
which supports multiple independent JScheme instances,
thanks to Toby Allsopp!
The JS class consists of static
methods for calling Scheme procedures from Java. 
In the JScheme class, all of those
methods are instance methods, and you must first create
a JScheme instance before you can call Scheme from Java using jscheme.JScheme
</li>
<li> <a href="modules.html">Modules</a> --
A new syntax "use-module" has been introduced for modules.
It allows one to selectively import bindings of procedures and/or
macros from modules. The idea is that modules are loaded into
an independent JScheme instance and then some of their bindings
are copied into the current JScheme instance (possibly adding
a prefix). Macro's are never prefixed however.
</li>
<li>
<a href="../src/jscheme/prims.scm">jscheme/prims.scm</a>
provides an implementation of all primitives directly in Scheme using
only javadot and the JScheme builtin special forms: 
<code>set!, lambda, macro, quote, if, or.</code>. It can be used like
<xmp>
(use-module "jscheme/prims.scm")
</xmp>
</li>
</ul>
<hr>

<h2>JScheme 6.3: 3/10/04</h2> 
<ul>
 <li> JScheme objects can now be serialized, thanks to Toby Allsopp
		<toby.allsopp@peace.com>,  see elf/serialize.scm.
 <li> <a href="http://swissnet.ai.mit.edu/~jaffer/SLIB.html">SLib</a>
support, see slib/jscheme.init.
 <li> Dynamic classpath extension, see elf/classpath.scm
 <li> (describe procedure) will pretty print the procedure's definition.
 <li> Long computations can be interrupted, see elf/interrupt.scm.
</ul>

<hr>
<h2> JScheme 6.0: 1/25/03 </h2>
<ul>
<li> <a href="modules.html">Modules</a> -- JScheme now has a simple
module facility</li>
</ul>
<hr>

<h2> JScheme 5.1: 5/3/02 </h2>
<ul>
<li> Quasi-string implementation has been modified slightly to make it
easier to use "map" inside quasi-strings
<ul>
<li> A Scheme expression appearing inside a quasi-string escape is
flattened and converted to a string before being inserted into the
quasi-string. This allows one to create structured representations of
strings which are then efficiently converted into strings in a single
flatten/string-append pass. For example, once can create a table
with two maps and a list of lists as follows:
<xmp>
{<table>
  [(map 
    (lambda(row)
      {<tr>
         [(map 
           (lambda(datum)
              {<td> [datum]</td>})
           row)]
      </tr>})
   '((name 8  9 10 11 12  1  2  3  4  5)
     (bill x  x  -  -  -  -  -  -  -  -)
     (sue  -  -  -  -  x  x  x  x  -  -)
     (jae  -  -  x  x  -  -  -  -  x  x)))]
  </table>}
</xmp>
</li>
<li>
Quasi-strings are now parsed by the reader into s-expressions
with the symbol "!&lt;&gt;" in the function position, e.g.
<xmp>
>> '{a[1]b[2]}
  (!<> "a" 1 "b" 2)
</xmp>
You can then redefine "!~&lt;&gt;" if you want to have them converted
into strings in a different way. 
</li>
</ul>
<hr>

<h2>
JScheme 5.0.0: 4/5/02
</h2>
<ul>
<li> The JScheme project has been refocussed to emphasize the applications of
JScheme to web programming.</li>
<br>
<li> JScheme has moved to a new home jscheme.sourceforge.net</li>
<br>
<li> We have added a jscheme webapp that can be dropped into the tomcat webserver
by Apache.
</li>
<br>
<li> The internal packages used by jscheme have changed names. 
(The jscheme package has remained the same so code that uses 
the jscheme API should not be affected.)
</li>
<br>

</ul>
<hr>

<h2>
JScheme 4.4.4: 3/29/02
</h2>
<ul>
<li> JScheme javadot notation now allows access to private fields, methods, and constructors
simply by adding a "#" at the end of the javadot name, e.g.
<pre>
  (.name$ 'a)  throws an error as name is a private field of jsint.Symbol
  (.name$# 'a) returns "a"

  (Symbol. "abc")  throws an error as Symbol is a private constructor, but
  (Symbol.# "abc") succeeds and generates an "uninterned" symbol

  (.equalFirsts '(a b) '(a c)) throws an error as equalFirsts is a private instance method of jsint.Pair, but
  (.equalFirsts# '(a b) '(a c)) returns #t

  (Pair.hashCode0 #null) throws an error as hashCode0 is a private static method of jsint.Pair, but
  (Pair.hashCode0# #null) returns 17, as it should

</pre>
</li>

<li> The new JScheme webpage is now on CVS</li>


</ul>
<hr>

<h2>
JScheme 4.4.2: 3/10/02
</h2>
<ul>
<li> JScheme 4.4.2 has many new extensions:
<ul>
<li> Quasi-string notation is now the default. This allows you to write code
in which {...} denotes a string (instead of "....") and hence you don't need to
quote the double quotes. The quasi-string notation also allows you to escape into
Scheme using [...] to generate an expression which will be inserted into the string.
For example, the following procedure creates an li element with class attribute c:
<xmp>
  (define (li c x) {<li class="[c]">[x]</li>})
</xmp>
The quasistring notation is converted (at read time) into the following scheme code
<xmp>
  (define (li c x) (string-append "<li class=\"" c "\">" x "</li>"))
</xmp>
Because []{} have a special role in JScheme, they must not appear in variables or symbols.
There is one exception which is that the pair of characters [] may appear inside symbols
names, thus 
<xml>
(define types '(Object Object[] java.lang.String[]))
</xml>
is allowed.
</li>
<li> There have been several bug fixes. (See the bug tracker at the sourceforge site.)</li>

</ul>
</ul>
<hr>
<h2>10 February 2002</h2>
<ul>
<li> Ken Anderson rewrote the way in which procedures are applied
in the jsint implementation of JScheme (with a 20-30% speed gain).</li>
<br>
<li> The define-macro macro was extended to allow for PLT style macros
(as suggested by Kirill Lisovsky).
The following are now equivalent:
<pre>
   (define-macro  f        (lambda(x) `(+ 1 ,x)))
   (define-macro (f x)            `(+ 1 ,x))
</pre>
</li>
<br>
<li> A simple networking library has been included in 
"jlib/Networking.scm" that can be used for implement peer-to-peer 
communication passing sexpressions.
</li>
<br>
<li> The JScheme webapp for tomcat has been released on this site
along with several interesting demos.</li>
<br>
<li> A new macro has been added to JScheme. This macro allows you
to switch on the type of the arguments: 
<pre>
   (class-case (a b)
     ((Integer.class Object.class) (list a b))
     ((Object.class Integer.class) (list b a))
     (else 'error))
</pre>
</li>
</ul>
<hr>
<h2>9 January 2002</h2>
<ul>
<li>
This page was added to the website.</li>
<li>
The <a href="../index.html"> main web page</a> was revised. 
</li>
</ul>

<hr>

</div>
</body>
</html>
